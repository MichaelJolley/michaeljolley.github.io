I"+<figure>
  <img src="https://user-images.githubusercontent.com/1228996/52905302-082afd00-31fe-11e9-9f0d-e1e02f2e58e9.png" />
</figure>

<p>This definitely has to be filed under ‚Äúremember this in the future.‚Äù</p>

<p>I‚Äôve been working on a project lately that includes a aspnetcore SPA using Angular.  It‚Äôs being deployed to multiple Raspberry Pi‚Äôs using a popular deployment tool.   However, as the number of devices used by the client grows the cost of the deployment tool is becoming prohibitive.  While exploring other options we landed on the Azure IoT Hub.</p>

<p>In production, the application on the Pi communicates with a Restful API that lives at the clients main office.  However, while debugging we need to run them side-by-side.  So, docker-compose to the rescue (I think.)</p>

<!--more-->

<h2>Setting up the Dockerfiles</h2>

<p>Most of our developers are using VS 2017 or 2019 so we used the built in functionality to add pre-built Dockerfile to the IoT application.</p>

<p>Once we started debugging we found our docker based IoT application couldn‚Äôt communicate with the localhost:port that the API was loaded to.  This made complete sense because the docker container thinks that it is localhost, not the host machine.  So we decided to load our API into a container.  Same steps, using Visual Studio to add the Dockerfile.</p>

<h2>The fun begins (or doesn‚Äôt)</h2>

<p>With the two Dockerfiles in place we setup a docker-compose that would launch each of them.  After reviewing multiple sites explaining varying ways to allow the two containers to communicate we finally found the correct solution.  So, for our future reminder, and possibly a chance to help others:</p>

<h2>How to setup a docker-compose file to allow communication between two or more containers on Windows</h2>

<p>While the wind-up for this post has been huge, actually getting the docker-compose right is fairly straight forward.</p>

<p>Firstly, add your two services in the docker compose like so:</p>

<pre><code class="language-YML">version 3.4

services:
  iotapp:
    image: ${DOCKER_REGISTRY-}iotapp
    build:
      context: .
      dockerfile: *path to your app Dockerfile here*
    ports:
      - {external port}:{internal port}
    links:
      - api
  api:
    image: ${DOCKER_REGISTRY-}api
    build:
      context: .
      dockerfile: *path to your api Dockerfile here*
    ports:
       - {external port}:{internal port}
</code></pre>

<p>Notice the <strong>links</strong> flag in the iotapp service.  This lets Docker know that iotapp will need to be able to communicate with the api project.</p>

<p>Pretty simple right?</p>

<p>The missing piece of the puzzle for us was how to communicate between the two.</p>

<p>For instance, in our iotapp code, it is hardcoded to communicate with <code class="highlighter-rouge">http://localhost:{port}/api</code>.  However, this won‚Äôt be okay because the api &amp; iotapp containers each have their own ‚Äúlocalhost‚Äù.  After much experimenting and several incorrect StackOverflow &amp; Google responses, we found you must call the name of the service specified in the docker-compose.  So any call in our iotapp to <code class="highlighter-rouge">http://localhost:{port}/api</code> needed to be changed to <code class="highlighter-rouge">http://api:{port}/api</code>.</p>

<p>Seeing what‚Äôs required and the ‚Äúhow-to‚Äù, it makes complete sense, but this one stumped me for several hours.  Hopefully if you‚Äôre reading this Google has sent you and it saves you that time.</p>

<p>Anything I missed or that we could do better?  Leave me a comment below.</p>
:ET